function [out] = SS_quantized(sim, rho)
%SS_Quantized superstabilizing control for quantized linear systems
% use affine-adjustable robust counterparts

%process the input

[n, T] = size(sim.X);
m = size(sim.U, 1);

if length(rho) = 1;
    rho = ones(m, 1)*rho;
end

(1+q)/(1-q);


%declare the variables

%uncertain (temporary)
A = sdpvar(n, n, 'full');
B = sdpvar(n, m, 'full');
rob_vars = [A(:); B(:)];

%design parameters
K = sdpvar(m, n, 'full');
lambda = sdpvar(1, 1, n);

M0 = sdpvar(n, n);
Ma = cell(length(rob_vars), 1);

%affine adjustable robust counterpart
M = M0;
for i = 1:length(rob_vars)
    Ma{i} = sdpvar(n, n);
    M = M +  Ma{i}*rob_vars(i);
end

signs = 2*ff2n(n)-1;


%start up constraint generation
lam_cons = [sum(M, 2) <= lambda];

%iterate over all sign patterns
I = eye(n);
ss_cons = [];
for i = 1:size(signs, 1)
    sign_curr = signs(i, :);
    
    Delta = diag(sign_curr.*rho);
    
    Acl_curr = A + B*(Delta + I)*K;
    
    ss_cons = [ss_cons; (M(:)-Acl(:)) >=0 ; (M(:)+Acl(:))>= 0];
end

%data processing

dd_term = [];
for i = 1:Nbucket
    if sim.buckets(i, 1) > -inf
        dd_low = Xp_curr - sim.lower(i, 1);
        dd_term = [dd_term; dd_low(sim.Sb{i})];
    end
    if sim.buckets(i, 2) < inf
        dd_high = (sim.higher(i, 2) - Xp_curr);
        dd_term = [dd_term; dd_high(sim.Sb{i})];
    end
end
dd_con = (dd_term>=0);


cons = [dd_con:'data'; lam_cons:'objective'; ss_cons:'M bounding'];

%solve the program
opts = sdpsettings('robust.lplp', 'duality');
sol = optimize(cons, lambda, opts);

disp(sol.info)

out = struct;
if sol.status ==0
    out.K = value(K);
    out.obj = value(lambda);
    


end

